<!-- Creator     : groff version 1.19.2 -->
<!-- CreationDate: Fri Aug 26 10:45:21 2011 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p     { margin-top: 0; margin-bottom: 0; }
       pre   { margin-top: 0; margin-bottom: 0; }
       table { margin-top: 0; margin-bottom: 0; }
</style>
<title>MPI_Comm_spawn</title>

</head>
<body>

<h1 align=center>MPI_Comm_spawn</h1>


<a name="NAME"></a>
<h2>NAME</h2>



<p style="margin-left:11%; margin-top: 1em"><b>MPI_Comm_spawn</b>
&minus; Spawns a number of identical binaries.</p>

<a name="SYNTAX"></a>
<h2>SYNTAX</h2>


<a name="C Syntax"></a>
<h2>C Syntax</h2>


<p style="margin-left:11%; margin-top: 1em">#include
&lt;mpi.h&gt; <br>
int MPI_Comm_spawn(char *<i>command</i>, char
*<i>argv</i>[], int <i>maxprocs</i>,</p>

<table width="100%" border=0 rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="85%">


<p valign="top">MPI_Info <i>info</i>, int <i>root</i>,
MPI_Comm <i>comm</i>,</p></td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="85%">


<p valign="top">MPI_Comm *<i>intercomm</i>, int
<i>array_of_errcodes</i>[])</p> </td>
</table>

<a name="Fortran Syntax"></a>
<h2>Fortran Syntax</h2>


<p style="margin-left:11%; margin-top: 1em">INCLUDE
&rsquo;mpif.h&rsquo; <br>
MPI_COMM_SPAWN(<i>COMMAND, ARGV, MAXPROCS, INFO, ROOT,
COMM,</i></p>

<table width="100%" border=0 rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">


<p valign="top"><i>INTERCOMM, ARRAY_OF_ERRCODES,
IERROR</i>)</p> </td>
<td width="8%"></td>
<td width="8%"></td>
<td width="69%">
</td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">


<p valign="top">CHARACTER*(*) <i>COMMAND, ARGV(*)</i></p></td>
<td width="8%"></td>
<td width="8%"></td>
<td width="69%">
</td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="8%"></td>
<td width="8%"></td>
<td width="69%">
</td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">


<p valign="top">INTEGER</p></td>
<td width="8%"></td>
<td width="8%"></td>
<td width="69%">


<p valign="top"><i>INFO, MAXPROCS, ROOT, COMM,
INTERCOMM,</i></p> </td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">


<p valign="top"><i>ARRAY_OF_ERRORCODES(*), IERROR</i></p></td>
<td width="8%"></td>
<td width="8%"></td>
<td width="69%">
</td>
</table>

<a name="C++ Syntax"></a>
<h2>C++ Syntax</h2>


<p style="margin-left:11%; margin-top: 1em">#include
&lt;mpi.h&gt; <br>
MPI::Intercomm MPI::Intracomm::Spawn(const char*
<i>command</i>,</p>

<table width="100%" border=0 rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p valign="top">const char* <i>argv</i>[], int
<i>maxprocs</i>, const MPI::Info&amp; <i>info</i>,</p></td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p valign="top">int <i>root</i>, int
<i>array_of_errcodes</i>[]) const</p></td>
</table>

<p style="margin-left:11%; margin-top: 1em">MPI::Intercomm
MPI::Intracomm::Spawn(const char* <i>command</i>,</p>

<table width="100%" border=0 rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p valign="top">const char* <i>argv</i>[], int
<i>maxprocs</i>, const MPI::Info&amp; <i>info</i>,</p></td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p valign="top">int <i>root</i>) const</p></td>
</table>

<a name="INPUT PARAMETERS"></a>
<h2>INPUT PARAMETERS</h2>


<table width="100%" border=0 rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="12%">


<p style="margin-top: 1em" valign="top">command</p></td>
<td width="3%"></td>
<td width="74%">


<p style="margin-top: 1em" valign="top">Name of program to
be spawned (string, significant only at <i>root</i>).</p></td>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="12%">


<p style="margin-top: 1em" valign="top">argv</p></td>
<td width="3%"></td>
<td width="74%">


<p style="margin-top: 1em" valign="top">Arguments to
<i>command</i> (array of strings, significant only at
<i>root</i>).</p> </td>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="12%">


<p style="margin-top: 1em" valign="top">maxprocs</p></td>
<td width="3%"></td>
<td width="74%">


<p style="margin-top: 1em" valign="top">Maximum number of
processes to start (integer, significant only at
<i>root</i>).</p> </td>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="12%">


<p style="margin-top: 1em" valign="top">info</p></td>
<td width="3%"></td>
<td width="74%">


<p style="margin-top: 1em" valign="top">A set of key-value
pairs telling the runtime system where and how to start the
processes (handle, significant only at <i>root</i>).</p></td>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="12%">


<p style="margin-top: 1em" valign="top">root</p></td>
<td width="3%"></td>
<td width="74%">


<p style="margin-top: 1em" valign="top">Rank of process in
which previous arguments are examined (integer).</p></td>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="12%">


<p style="margin-top: 1em" valign="top">comm</p></td>
<td width="3%"></td>
<td width="74%">


<p style="margin-top: 1em" valign="top">Intracommunicator
containing group of spawning processes (handle).</p></td>
</table>

<a name="OUTPUT PARAMETER"></a>
<h2>OUTPUT PARAMETER</h2>


<table width="100%" border=0 rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="14%">


<p style="margin-top: 1em" valign="top">intercomm</p></td>
<td width="1%"></td>
<td width="74%">


<p style="margin-top: 1em" valign="top">Intercommunicator
between original group and the newly spawned group
(handle).</p> </td>
</table>

<p style="margin-left:11%;">array_of_errcodes</p>

<p style="margin-left:26%;">One code per process (array of
integers).</p>

<table width="100%" border=0 rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p style="margin-top: 1em" valign="top">IERROR</p></td>
<td width="6%"></td>
<td width="57%">


<p style="margin-top: 1em" valign="top">Fortran only: Error
status (integer).</p></td>
<td width="17%">
</td>
</table>

<a name="DESCRIPTION"></a>
<h2>DESCRIPTION</h2>


<p style="margin-left:11%; margin-top: 1em">MPI_Comm_spawn
tries to start <i>maxprocs</i> identical copies of the MPI
program specified by <i>command</i>, establishing
communication with them and returning an intercommunicator.
The spawned processes are referred to as children. The
children have their own MPI_COMM_WORLD, which is separate
from that of the parents. MPI_Comm_spawn is collective over
<i>comm</i>, and also may not return until MPI_Init has been
called in the children. Similarly, MPI_Init in the children
may not return until all parents have called MPI_Comm_spawn.
In this sense, MPI_Comm_spawn in the parents and MPI_Init in
the children form a collective operation over the union of
parent and child processes. The intercommunicator returned
by MPI_Comm_spawn contains the parent processes in the local
group and the child processes in the remote group. The
ordering of processes in the local and remote groups is the
same as the as the ordering of the group of the <i>comm</i>
in the parents and of MPI_COMM_WORLD of the children,
respectively. This intercommunicator can be obtained in the
children through the function MPI_Comm_get_parent.</p>

<p style="margin-left:11%; margin-top: 1em">The MPI
standard allows an implementation to use the
MPI_UNIVERSE_SIZE attribute of MPI_COMM_WORLD to specify the
number of processes that will be active in a program.
Although this implementation of the MPI standard defines
MPI_UNIVERSE_SIZE, it does not allow the user to set its
value. If you try to set the value of MPI_UNIVERSE_SIZE, you
will get an error message.</p>

<p style="margin-left:11%; margin-top: 1em">The
<i>command</i> Argument</p>

<p style="margin-left:11%; margin-top: 1em">The
<i>command</i> argument is a string containing the name of a
program to be spawned. The string is null-terminated in C.
In Fortran, leading and trailing spaces are stripped. MPI
looks for the file first in the working directory of the
spawning process.</p>

<p style="margin-left:11%; margin-top: 1em">The <i>argv</i>
Argument</p>

<p style="margin-left:11%; margin-top: 1em"><i>argv</i> is
an array of strings containing arguments that are passed to
the program. The first element of <i>argv</i> is the first
argument passed to <i>command</i>, not, as is conventional
in some contexts, the command itself. The argument list is
terminated by NULL in C and C++ and an empty string in
Fortran (note that it is the MPI application&rsquo;s
responsibility to ensure that the last entry of the
<i>argv</i> array is an empty string; the compiler will not
automatically insert it). In Fortran, leading and trailing
spaces are always stripped, so that a string consisting of
all spaces is considered an empty string. The constant
MPI_ARGV_NULL may be used in C, C++ and Fortran to indicate
an empty argument list. In C and C++, this constant is the
same as NULL.</p>

<p style="margin-left:11%; margin-top: 1em">In C, the
MPI_Comm_spawn argument <i>argv</i> differs from the
<i>argv</i> argument of <i>main</i> in two respects. First,
it is shifted by one element. Specifically, <i>argv</i>[0]
of <i>main</i> contains the name of the program (given by
<i>command</i>). <i>argv</i>[1] of <i>main</i> corresponds
to <i>argv</i>[0] in MPI_Comm_spawn, <i>argv</i>[2] of
<i>main</i> to <i>argv</i>[1] of MPI_Comm_spawn, and so on.
Second, <i>argv</i> of MPI_Comm_spawn must be
null-terminated, so that its length can be determined.
Passing an <i>argv</i> of MPI_ARGV_NULL to MPI_Comm_spawn
results in <i>main</i> receiving <i>argc</i> of 1 and an
<i>argv</i> whose element 0 is the name of the program.</p>

<p style="margin-left:11%; margin-top: 1em">The
<i>maxprocs</i> Argument</p>

<p style="margin-left:11%; margin-top: 1em">Open MPI tries
to spawn <i>maxprocs</i> processes. If it is unable to spawn
<i>maxprocs</i> processes, it raises an error of class
MPI_ERR_SPAWN. If MPI is able to spawn the specified number
of processes, MPI_Comm_spawn returns successfully and the
number of spawned processes, <i>m</i>, is given by the size
of the remote group of <i>intercomm</i>.</p>

<p style="margin-left:11%; margin-top: 1em">A spawn call
with the default behavior is called hard. A spawn call for
which fewer than <i>maxprocs</i> processes may be returned
is called soft.</p>

<p style="margin-left:11%; margin-top: 1em">The <i>info</i>
Argument</p>

<p style="margin-left:11%; margin-top: 1em">The <i>info</i>
argument is an opaque handle of type MPI_Info in C,
MPI::Info in C++ and INTEGER in Fortran. It is a container
for a number of user-speci ed (<i>key,value</i>) pairs.
<i>key</i> and <i>value</i> are strings (null-terminated
char* in C, character*(*) in Fortran). Routines to create
and manipulate the <i>info</i> argument are described in
Section 4.10 of the MPI-2 standard.</p>

<p style="margin-left:11%; margin-top: 1em">For the SPAWN
calls, <i>info</i> provides additional,
implementation-dependent instructions to MPI and the runtime
system on how to start processes. An application may pass
MPI_INFO_NULL in C or Fortran. Portable programs not
requiring detailed control over process locations should use
MPI_INFO_NULL.</p>

<p style="margin-left:11%; margin-top: 1em">The following
keys for <i>info</i> are recognized in Open MPI. (The
reserved values mentioned in Section 5.3.4 of the MPI-2
standard are not implemented.)</p>

<p style="margin-left:11%; margin-top: 1em">Key Type
Description <br>
--- ---- -----------</p>

<p style="margin-left:11%; margin-top: 1em">host char *
Host on which the process should be spawned. <br>
See the <i>orte_host</i> man page for an <br>
explanation of how this will be used. <br>
hostfile char * Hostfile containing the hosts on which <br>
the processes are to be spawned. See <br>
the <i>orte_hostfile</i> man page for an <br>
explanation of how this will be used. <br>
add-host char * Add the specified host to the list of <br>
hosts known to this job and use it <br>
for the associated process. This will <br>
be used similarly to the -host option. <br>
add-hostfile char * Hostfile containing hosts to be added
<br>
to the list of hosts known to this job and <br>
use it for the associated process. This will <br>
be used similarly to the -hostfile option. <br>
wdir char * Directory where the executable is located. If
<br>
files are to be pre-positioned, then this <br>
location is the desired working directory <br>
at time of execution - if not specified, <br>
then it will automatically be set to <i><br>
ompi_preload_files_dest_dir</i>. <br>
ompi_prefix char * Same as the --prefix command line
argument <br>
to mpirun. <br>
ompi_local_slave bool If set to true, launch the specified
process <br>
as a local <i>slave</i> to the calling process. <br>
The new process will only be known to the caller, <br>
and will only be able to communicate with the caller. <br>
ompi_preload_binary bool If set to true, pre-position the
specified <br>
executable onto the remote host. A destination <br>
directory must also be provided. <br>
ompi_preload_files_dest_dir char * Target directory where
pre-positioned files <br>
are to be placed. <br>
ompi_preload_files char * A comma-separated list of files
that are to <br>
be pre-positioned in addition to the executable. <br>
Note that this option does not depend upon <i><br>
ompi_preload_binary</i> - files can be moved <br>
to the target even if an executable is not moved. <br>
ompi_preload_files_src_dir char * Source directory where
files and executables <br>
that are to be pre-positioned can be found. If <br>
not specified, the current working directory <br>
will be used. <br>
ompi_non_mpi bool If set to true, launching a non-MPI <br>
application; the returned communicator <br>
will be MPI_COMM_NULL. Failure to set <br>
this flag when launching a non-MPI <br>
application will cause both the child <br>
and parent jobs to &quot;hang&quot;. <br>
ompi_param char * Pass an OMPI MCA parameter to the child
job. <br>
If that parameter already exists in the <br>
environment, the value will be overwritten <br>
by the provided value. <br>
map_bynode bool If set to true, the processes are mapped
bynode. <br>
If set to false, the processes are mapped byslot. <br>
By default, mapping is determined by the default <br>
mapping policy set when the job was started.</p>

<p style="margin-left:11%; margin-top: 1em"><i>bool</i>
info keys are actually strings but are evaluated as follows:
if the string value is a number, it is converted to an
integer and cast to a boolean (meaning that zero integers
are false and non-zero values are true). If the string value
is (case-insensitive) &quot;yes&quot; or &quot;true&quot;,
the boolean is true. If the string value is
(case-insensitive) &quot;no&quot; or &quot;false&quot;, the
boolean is false. All other string values are unrecognized,
and therefore false.</p>

<p style="margin-left:11%; margin-top: 1em">The <i>root</i>
Argument</p>

<p style="margin-left:11%; margin-top: 1em">All arguments
before the <i>root</i> argument are examined only on the
process whose rank in <i>comm</i> is equal to <i>root</i>.
The value of these arguments on other processes is
ignored.</p>

<p style="margin-left:11%; margin-top: 1em">The
<i>array_of_errcodes</i> Argument</p>

<p style="margin-left:11%; margin-top: 1em">The
<i>array_of_errcodes</i> is an array of length
<i>maxprocs</i> in which MPI reports the status of the
processes that MPI was requested to start. If all
<i>maxprocs</i> processes were spawned,
<i>array_of_errcodes</i> is filled in with the value
MPI_SUCCESS. If anyof the processes are <i>not</i> spawned,
<i>array_of_errcodes</i> is filled in with the value
MPI_ERR_SPAWN. In C or Fortran, an application may pass
MPI_ERRCODES_IGNORE if it is not interested in the error
codes. In C++ this constant does not exist, and the
<i>array_of_errcodes</i> argument may be omitted from the
argument list.</p>

<a name="NOTES"></a>
<h2>NOTES</h2>


<p style="margin-left:11%; margin-top: 1em">Completion of
MPI_Comm_spawn in the parent does not necessarily mean that
MPI_Init has been called in the children (although the
returned intercommunicator can be used immediately).</p>

<a name="ERRORS"></a>
<h2>ERRORS</h2>


<p style="margin-left:11%; margin-top: 1em">Almost all MPI
routines return an error value; C routines as the value of
the function and Fortran routines in the last argument. C++
functions do not return errors. If the default error handler
is set to MPI::ERRORS_THROW_EXCEPTIONS, then on error the
C++ exception mechanism will be used to throw an
MPI:Exception object.</p>

<p style="margin-left:11%; margin-top: 1em">Before the
error value is returned, the current MPI error handler is
called. By default, this error handler aborts the MPI job,
except for I/O function errors. The error handler may be
changed with MPI_Comm_set_errhandler; the predefined error
handler MPI_ERRORS_RETURN may be used to cause error values
to be returned. Note that MPI does not guarantee that an MPI
program can continue past an error.</p>

<a name="SEE ALSO"></a>
<h2>SEE ALSO</h2>



<p style="margin-left:11%; margin-top: 1em"><a href="MPI_Comm_spawn_multiple.html">MPI_Comm_spawn_multiple</a>(3)
<br>
<a href="MPI_Comm_get_parent.html">MPI_Comm_get_parent</a>(3) <br>
 mpirun(1)</p>
<hr>
<a href="allindex.html">MPI API Index</a></body>
</html>
